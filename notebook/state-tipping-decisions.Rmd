---
output: github_document
title: The Forecasting Trap -- notes
---


```{r setup, message=FALSE}
library(MDPtoolbox)
library(sarsop)
library(tidyverse) # for plotting
library(mdplearning) # remotes::install_github("boettiger-lab/mdplearning")
```



```{r}
states <- seq(0,30, length=100)
actions <- seq(0,30, length.out = 100)
observations <- states
sigma_g <- 0.05
sigma_m <- 0.0

benefit <- 1
cost <- 1 # quadratic costs
reward_fn <- function(x,h) benefit * x - (h ^ cost)
discount <- 0.999

#p <- list(r =.7, K = 1.2, q = 3, b = 0.15, a = 0.2) # lower-state peak is optimal
p <- list(r = 2, K = 25, q = 4, b = 2, a = 7) # higher-state peak is optimal

may <- 
  function(x, h = 0){ # May
    y <- x +  h
    pmax(
      ## controlling h is controlling the bifurcation point directly...
      y + y * p$r * (1 - y / p$K)  - p$a * y ^ p$q / (y ^ p$q + p$b ^ p$q),  
      0)
  }



# Matches the optimal policy under these settings (depends on sigma, among others)
logistic_1 <- 
  function(x, h = 0){
    y = x+h
    pmax(
      y + y * (p$r - .65) * (1 - y / p$K),  
      0)
  }



alt  <- function(x, h = 0, r = .095, K = 20){
  s <- pmax(x - h, 0)
  s + s ^ 2 * r * (1 - s / K)
}







bh <- 
  function(x, h = 0){
    y = x+h
    A <- 1.3 * p$r
    B <- .6 * p$K / (p$r - 1)
    pmax(
      y * A / (1 + y / B),  
      0)
  }


logistic_2 <- function(x, h = 2) logistic(x,h)
may_2 <- function(x, h = 2) may(x,h)
may_10 <- function(x, h = 10) may(x,h)
```



```{r}
## True model is May,
alt2  <- function(x, h = 0, r = .05, K = 10){
  s <- pmax(x - h, 0)
  s + s ^ 2 * r * (1 - s / K)
}

models <- list(logistic_1 = logistic_1, alt = alt, may =  may, alt2=alt2)
landscape <- map_dfr(models, 
                     function(f) tibble(state = states, f = f(states) -states),
                     .id = "model")

landscape %>% ggplot(aes(state, f, col=model)) + geom_point(alpha=0.8) + geom_line() + ylim(-5,10) + xlim(0,5)
```

## Optimal management


```{r}
matrices <- lapply(models, 
       function(f) fisheries_matrices(states, actions, observations, reward_fn, 
                        f, sigma_g, sigma_m, noise = "lognormal")
)
```


```{r, results="hide"}
#solns <- lapply(matrices, function(m) mdp_value_iteration(m$transition, m$reward, discount))
solns <- lapply(matrices, function(m) mdp_policy_iteration(m$transition, m$reward, discount, policy0 = rep(1,length(states)), max_iter = 5000))

```


```{r}
df <- map_dfr(solns, function(soln)
        tibble(state = states,
               action = actions[soln$policy],
               value = soln$V),
  .id = "model")

df
```



```{r}
df %>% ggplot(aes(state, action, col=model)) + geom_line(alpha=0.7) + geom_point(alpha=0.6) + ggtitle("Policy Functions")

#+
#  geom_line(aes(state, f), col = "red")  + 
#  coord_cartesian(xlim=c(0,1.3), ylim = c(-2, 3))
```



```{r fig.cap="Under the true model, agressive conservation in Year 1 is optimal, restoring the system to the desirable stable point"}
m <- matrices[[3]]
x0 = which.min(abs(states - 3.5))
sim <- mdp_planning(m$transition, m$reward, discount, model_prior = c(1), 
                   policy = solns[[3]]$policy, x0 = x0, Tmax = 100)
sim %>% mutate(state = states[state], action = actions[action]) %>% 
  ggplot(aes(time, state)) + geom_point()+geom_path() + 
  geom_point(aes(time, action), col="blue") +
  ggtitle("Optimal management under the true model")



```


```{r }
m <- matrices[[3]] # generative process
x0 = which.min(abs(states - 3.5))
sim <- mdp_planning(m$transition, m$reward, discount, model_prior = c(1), 
                   policy = solns[[2]]$policy, x0 = x0, Tmax = 100)

sim %>% mutate(state = states[state], action = actions[action]) %>% 
  ggplot(aes(time, state)) + geom_point()+geom_path() + 
  geom_point(aes(time, action), col="blue") +
  ggtitle("Optimal management under the true model")



```


# Tipping

```{r}


p <- list(r =.7, K = 1.2, q = 3, b = 0.15, a = 0.2) # lower-state peak is optimal
#p <- list(r =.7, K = 1.5, q = 3, b = 0.15, a = 0.2) # higher-state peak is optimal

may <- function(a) 
  function(x, h = 0){ # May
    y <- x +  h
    pmax(
      ## controlling h is controlling the bifurcation point directly...
      y + y * p$r * (1 - y / p$K)  - a * y ^ p$q / (y ^ p$q + p$b ^ p$q),  
      0)
  }

df <- seq(0.1, 0.26, by = 0.001) %>%
  map_dfr(function(a) tibble(x = states, f = may(a)(x,0) - x, a = a))
df %>% 
  ggplot(aes(x, f)) + 
    geom_line(aes(group = a, col = a), lwd = 1) +
    geom_line(data=dplyr::filter(df, near(a, 0.215)), col = "purple", lwd = 1) +
    geom_hline(aes(yintercept = 0)) + coord_cartesian(ylim = c(-.2, .1), xlim = c(0,1.5))
```
