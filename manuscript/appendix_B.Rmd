---
title: 'Appendix B'
date: "`r Sys.Date()`"
author: Carl Boettiger
journal: Appendix
layout: 3p
bibliography: refs.bib
#output:
#  tufte::tufte_handout:
#    dev: cairo_pdf
#    latex_engine: xelatex
output: 
  hrbrthemes::ipsum_pdf:
    dev: cairo_pdf
    latex_engine: xelatex

---


```{r model_definitions}
states <- seq(0,24, length.out = 240)
actions <- states
obs <- states
```

```{r}
reward_fn <- function(x,h) pmin(x,h)
discount <- 0.99
```



```{r graphics_setup, message=FALSE, warning=FALSE, include = FALSE}
## Plotting themes, colors, and fonts 
## aesthetics choices only, all can be omitted without consequence
library(ggthemes)
library(hrbrthemes)
library(ggplot2)
library(Cairo)
library(extrafont)
library(patchwork)
library(styler)
extrafont::loadfonts(quiet = TRUE)
ggplot2::theme_set(hrbrthemes::theme_ipsum_rc())

scale_colour_discrete <- function(...) ggthemes::scale_colour_solarized()
scale_fill_discrete <- function(...) ggthemes::scale_fill_solarized()
pal <- ggthemes::solarized_pal()(8)
txtcolor <- "#586e75"

knitr::opts_chunk$set(cache=FALSE, tidy = "styler", message = FALSE, warning = FALSE, echo = FALSE)

```

```{r setup, message=FALSE}
library(tidyverse)
library(MDPtoolbox)
library(expm)
# remotes::install_github("boettiger-lab/mdplearning")
library(mdplearning)
```


```{r}
# max is at 4 * K / 5 
f3  <- function(x, h = 0, r = .002, K = 10){
  s <- pmax(x - h, 0)
  s + s ^ 4 * r * (1 - s / K)
}
```


```{r}
library(nimble)

logistic  <- nimble::nimbleCode({
  
  x[1] <- x0
  for(t in 1:(N-1)){
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K)  
    x[t+1] ~ dlnorm(log(mu[t]), sd = sigma)
  }
  r ~ dunif(0,10);
  K ~ dunif(0,20);
  sigma ~ dunif(0,0.1);
  
})
l_model <- nimbleModel(logistic,constants = list(N = 1e3, x0 = 6.0))



f3_nimble  <- nimble::nimbleCode({
  x[1] <- x0
  for(t in 1:(N-1)){
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K)  
    x[t+1] ~ dlnorm(log(mu[t]), sd = sigma)
  }
})
model <- nimbleModel(f3_nimble, constants = list(r = .002, K = 10, sigma = .05, N = 1e3), inits = list(x0 = 6.0))

simulate(model)
ggplot(data.frame(t = 1:1e3, x = model$x), aes(t,x)) + geom_line()
```
```{r}
l_model$setData(list(x = model$x))
c_model <- compileNimble(l_model)
l_mcmc <- buildMCMC(c_model)
c_mcmc <- compileNimble(l_mcmc)
df <- runMCMC(c_mcmc, niter = 10000, nburnin = 1000)

A <- df %>% as_tibble() %>% summarise(across(everything(), list(mean = mean, sd = sd)))
```




```{r}
rs <-A$r_mean #10 ^ seq(log10(.01), log10(2), length=60)
Ks <- A$K_mean # seq(1,16,length=50) # 10^ seq(log10(1), log10(16), length=7)

# compare over fixed set of candidate r and K
n_models <- length(rs)*length(Ks)
sigmas <- 0.05
pars <- expand.grid(rs, Ks)
names(pars) <- c("r", "K")
pars$sigma <- sigmas

closure <- function(r, K){
  function(x, h = 0){
  s <- pmax(x - h, 0)
  s + s * (r * (1 - s / K) )
  }
}

models <-  lapply(1:n_models, function(i) closure(pars[i,"r"], pars[i,"K"]))

## gather models together, indicate true model
sigma_g <- 0.05
model_sigmas <- pars$sigma
```




```{r transition_matrices}
transition_matrices <- function(f, states, actions, sigma_g){
  n_s <- length(states)
  n_a <- length(actions)
  transition <- array(0, dim = c(n_s, n_s, n_a))
  for (k in 1:n_s) {
    for (i in 1:n_a) {
      nextpop <- f(states[k], actions[i])
      if(nextpop <= 0){
        transition[k, , i] <- c(1, rep(0, n_s - 1))
      } else if(sigma_g > 0){
        x <- dlnorm(states, log(nextpop), sdlog = sigma_g)
        if(sum(x) == 0){ ## nextpop is computationally zero
          transition[k, , i] <- c(1, rep(0, n_s - 1))
        } else {
          x <- x / sum(x) # normalize evenly
          transition[k, , i] <- x
        }
      }
    }
  }
  transition
}
```


```{r}
transitions <- lapply(seq_along(models), 
                      function(i) transition_matrices(models[[i]], 
                                                      states, 
                                                      actions, 
                                                      model_sigmas[[i]]))
names(transitions) <- as.character(seq_along(models))

true_transition <- transition_matrices(f3, states, actions, sigma_g)
```



````{r}
## Compute reward matrix (shared across all models)
n_s <- length(states)
n_a <- length(actions)
reward <- array(0, dim = c(n_s, n_a))
for (k in 1:n_s) {
  for (i in 1:n_a) {
    reward[k, i] <- reward_fn(states[k], actions[i])
  }
}
```

# Plot Models 



```{r plot_models, fig.width=10, fig.height=7}
model_set <-c(f3,  models)
names(model_set) <- c("true", 1:length(models))
d <- 
  map_dfc(model_set, function(f) f(states) - states) %>%
  mutate(state = states)

d %>% pivot_longer(names(model_set[-1]), "model") %>%
  ggplot(aes(state, value, col = model)) +
  geom_hline(aes(yintercept = 0), lwd=1) + 
  geom_line(alpha = .5, show.legend = FALSE) + 
  geom_line(aes(state, true), col = "red") +
  coord_cartesian(ylim = c(-5, 8), xlim = c(0,16)) +
  ylab(bquote(f(x) - x)) + xlab("x") + scale_color_grey()
```

# Non-adaptive management over model uncertainty

With strong prior probabilities weighted to Model 1

```{r}
x0 <- which.min(abs(states - 6))
## start with 99% weight on 'model 1'
model_prior <- c(rep(.01, length(models)-1) / (length(models) - 1), .99)

```

```{r}
policy_sdp <- memoise::memoise(mdp_compute_policy, cache = memoise::cache_filesystem("cache/"))

policy <- policy_sdp(transitions,  
                     reward = reward, 
                     discount = discount,
                     model_prior = model_prior,
                     Tmax = 20, 
                     epsilon = 0.001, 
                     max_iter = 2000)

policy %>% mutate(state = states[state], quota = actions[policy]) %>% mutate(escapement = state - quota) %>% ggplot(aes(state, escapement)) + geom_line()
```





```{r}

non_am <- mdp_planning(true_transition,  
                       reward = reward, 
                       discount = discount,
                       model_prior = model_prior,
                       x0 = x0, 
                       a0 = 1,
                       policy = policy$policy,
                       Tmax = 20)

non_am %>% mutate(state = states[state]) %>% ggplot(aes(time, state)) + geom_point() + geom_line()

```



# Adaptive Management

Passive adaptive management, with initial strong prior probabilities weighted to Model 1.  

```{r}
adaptive_management <- memoise::memoise(mdp_learning, cache = memoise::cache_filesystem("cache/"))

am_many <- adaptive_management(transitions,  
                           reward = reward, 
                           discount = discount,
                           model_prior = model_prior,
                           x0 = x0, 
                           Tmax = 20, 
                           true_transition = true_transition, 
                           epsilon = 0.001, 
                           max_iter = 2000)
```


```{r}
Tmax <- max(am_many$df$time)
best_i <- which.max(am_many$posterior[Tmax,])
good_i <- am_many$posterior[Tmax,] > 0.1
pars[good_i,] %>% mutate(final_prob = as.numeric(am_many$posterior[Tmax,good_i])) 
```



```{r}
model1 <- dim(am_many$posterior)[2]

am_multi <- am_many$df %>% 
  mutate(belief = am_many$posterior[,model1],
         stock = states[state],
         quota = actions[action]) %>%
  select(time, belief, stock, quota) 
write_csv(am_multi, "../data/am_multi.csv")
```

```{r}
am_multi %>%
  ggplot(aes(time, stock, col = belief)) + 
  geom_line() + 
  geom_point() +
  geom_point(aes(time, quota), col="darkgreen", shape=2) + 
  scale_colour_gradient(limits = c(0,1), low = pal[4], high = pal[1]) + 
  ylab("fish stock") + labs(caption = "Belief in model 1 falls off rapidly as magagement pushes stocks to lower and lower sizes.")



```



```{r}
posteriors <- data.frame(r = rs, K = Ks, t(am_many$posterior)) %>%
  pivot_longer(starts_with("X"), 
               values_to = "probability",
               names_to = "time") %>% 
  mutate(time = as.integer(as.factor(time))) 

i <- 20
r_marginals <- posteriors %>% group_by(time,r) %>% 
  summarise(prob = sum(probability), .groups = "drop") %>% 
  filter(time %in% i)

r_marginals %>%  ggplot(aes(r, prob, group=time)) + geom_bar(stat="identity") + facet_wrap(~time)
```


## Marginal Posterior Probability evolution over K

```{r}
i = 20
K_marginals <- posteriors %>% group_by(time,K) %>% 
  summarise(prob = sum(probability), .groups = "drop") %>% 
  filter(time %in% i) 
K_marginals %>%
  ggplot(aes(K, prob, group=time)) + geom_bar(stat="identity") + facet_wrap(~time) + scale_x_log10()


```



```{r}
am_npv <- sum(am_many$df$value * discount ^ am_many$df$time)
am_npv
```




